

Analysis of G16HW1.py

Description of MRPrintStatistics()
Some general notations:
L = number of partitions; K = set of centroids; N = number of points; ki = centroid i in K.

Round 1
* Map phase: for every 0 <= j < N and 0 <= i < |K| separately (coordj, gj ) -> (ki, (coordj, gj))
where coordj are coordinates of point in RDD, gj is the group of the point of index j.
* Reduce phase: for every 0 <= p < L separately  (ki, (coordj, gj)) -> (j mod L, (kip, (SAip, SBip))) where SAip and SBip are respectively the number of points with label A and B and related to kip.
Round 2
* Map phase: -
* Reduce phase: (ki, Si) -> (ki, (NAi, NBi)) where Si is a list of pairs of values SAip, SBip related to ki. 
NAi = \sum_{\mathrm{p=0}}^{\mathrm{L-1}}SAip  and NBi = \sum_{\mathrm{p=0}}^{\mathrm{L-1}}SBip . 

Analysis of MRPrintStatistics()
Rounds = 2

Round 1
- Map phase : O(K)
In the first map phase we have used flatMap().
parse_coors_group() is a conversion of points with complexity O(1).
calc_center() computes the distance from each point to all centroids. The complexity is O(K).
- Reduce phase: O(N*K/L)
The complexity of mapPartitions() is O(N/L).
For each centroid, we compute the sum of points A , B in the partition and in the worst case the complexity is O(K).
Round 2
- Map phase: O(1)
- Reduce phase: O(L)
In input of the last reduce phase we can have at most L tuples, one for each partition.

ML = O(max{O(K), O(N*K/L), O(1), O(L)}) = O(N*K/L )
